<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN" "http://jats.nlm.nih.gov/publishing/1.1d3/JATS-journalpublishing1.dtd">
<article article-type="research-article" dtd-version="1.1d3" xml:lang="en" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS ONE</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">plosone</journal-id>
<journal-title-group>
<journal-title>PLOS ONE</journal-title>
</journal-title-group>
<issn pub-type="epub">1932-6203</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1371/journal.pone.0209159</article-id>
<article-id pub-id-type="publisher-id">PONE-D-18-20777</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Physics</subject><subj-group><subject>Thermodynamics</subject><subj-group><subject>Entropy</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Information theory</subject><subj-group><subject>Information entropy</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Data management</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Algebra</subject><subj-group><subject>Linear algebra</subject><subj-group><subject>Vector spaces</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Anatomy</subject><subj-group><subject>Musculoskeletal system</subject><subj-group><subject>Pelvis</subject><subj-group><subject>Hip</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Medicine and health sciences</subject><subj-group><subject>Anatomy</subject><subj-group><subject>Musculoskeletal system</subject><subj-group><subject>Pelvis</subject><subj-group><subject>Hip</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Engineering and technology</subject></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Number theory</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Suitability of a new Bloom filter for numerical vectors with high dimensions</article-title>
<alt-title alt-title-type="running-head">A new BF for numerical vectors with HD</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8282-2697</contrib-id>
<name name-style="western">
<surname>Shuai</surname>
<given-names>Chunyan</given-names>
</name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Lei</surname>
<given-names>Jiayou</given-names>
</name>
<role content-type="http://credit.casrai.org/">Methodology</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Gong</surname>
<given-names>Zeweiyi</given-names>
</name>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<name name-style="western">
<surname>Ouyang</surname>
<given-names>Xin</given-names>
</name>
<role content-type="http://credit.casrai.org/">Data curation</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Software</role>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
</contrib-group>
<aff id="aff001"><label>1</label> <addr-line>Faculty of Transportation Engineering, Kunming University of Science and Technology, Kunming, China</addr-line></aff>
<aff id="aff002"><label>2</label> <addr-line>Faculty of Electric Power Engineering, Kunming University of Science and Technology, Kunming, China</addr-line></aff>
<aff id="aff003"><label>3</label> <addr-line>Faculty of Information Engineering and Automation, Kunming University of Science and Technology, Kunming, China</addr-line></aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Li</surname>
<given-names>Zhan</given-names>
</name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1"><addr-line>University of Electronic Science and Technology of China, CHINA</addr-line></aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">kmoyx@hotmail.com</email></corresp>
</author-notes>
<pub-date pub-type="epub">
<day>21</day>
<month>12</month>
<year>2018</year>
</pub-date>
<pub-date pub-type="collection">
<year>2018</year>
</pub-date>
<volume>13</volume>
<issue>12</issue>
<elocation-id>e0209159</elocation-id>
<history>
<date date-type="received">
<day>13</day>
<month>7</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>2</day>
<month>12</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-year>2018</copyright-year>
<copyright-holder>Shuai et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pone.0209159"/>
<abstract>
<p>The notable increase in the size and dimensions of data have presented challenges for data storage and retrieval. The Bloom filter and its generations, due to efficient space overheads and constant query delays, have been broadly applied to querying memberships of a big data set. However, the Bloom filter and most of the variants regard each element as a 1-dimensional string and adopt multiple different string hashes to project the data. The interesting problem is when the inputs are numerical vectors with high dimensions, it remains unknown whether they can be projected into the Bloom filter in their original format. Furthermore, we investigate whether the projection is random and uniform. To address these problems, this paper presents a new uniform Prime-HD-BKDERhash family and a new Bloom filter (P-HDBF) to retrieve the membership of a big data set with the numerical high dimensions. Since the randomness and uniformity of data mapping determines the performance of the Bloom filter, to verify these properties, we first introduce information entropy. Our theoretical and experimental results show that the P-HDBF can randomly and uniformly map the data in their native formats. Moreover, the P-HDBF provides an efficient solution alternative to implement membership search with space-time overheads. This advantage may be suitable for engineering applications that are resource-constrained or identification of the nuances of the graphics and images.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution>National Key R&amp;D Plan of China</institution>
</funding-source>
<award-id>2017YFB0306405</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Ouyang</surname>
<given-names>Xin</given-names>
</name>
</principal-award-recipient>
</award-group>
<award-group id="award002">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100001809</institution-id>
<institution>National Natural Science Foundation of China</institution>
</institution-wrap>
</funding-source>
<award-id>61562056,61364008</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8282-2697</contrib-id>
<name name-style="western">
<surname>Shuai</surname>
<given-names>Chunyan</given-names>
</name>
</principal-award-recipient>
</award-group>
<funding-statement>This work is supported by the National Key R&amp;D Plan of China (No. 2017YFB0306405) to XO, the National Natural Science Foundation of China (No.61562056, No.61364008) to CS. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="11"/>
<table-count count="0"/>
<page-count count="15"/>
</counts>
<custom-meta-group>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>Data are available freely from <ext-link ext-link-type="uri" xlink:href="http://corpus-texmex.irisa.fr/" xlink:type="simple">http://corpus-texmex.irisa.fr/</ext-link> and on figshare at the URLs: <ext-link ext-link-type="uri" xlink:href="https://figshare.com/articles/sift_data/7428974" xlink:type="simple">https://figshare.com/articles/sift_data/7428974</ext-link> and <ext-link ext-link-type="uri" xlink:href="https://figshare.com/articles/ivecs_read_m/7428971" xlink:type="simple">https://figshare.com/articles/ivecs_read_m/7428971</ext-link>.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<sec id="sec001" sec-type="intro">
<title>1. Introduction</title>
<p>With increasing data sizes, concise data representations and efficient query algorithms have become the key factors to large-scale data management. As a result, a large number of technologies have appeared, such as the Bloom filter (BF) [<xref ref-type="bibr" rid="pone.0209159.ref001">1</xref>]. The BF has a low query delay and a high time-space overhead, leading to its broad use in computing areas, such as network and network security [<xref ref-type="bibr" rid="pone.0209159.ref002">2</xref>–<xref ref-type="bibr" rid="pone.0209159.ref005">5</xref>], distributed systems [<xref ref-type="bibr" rid="pone.0209159.ref006">6</xref>–<xref ref-type="bibr" rid="pone.0209159.ref009">9</xref>] and applications or embedded devices [<xref ref-type="bibr" rid="pone.0209159.ref010">10</xref>,<xref ref-type="bibr" rid="pone.0209159.ref011">11</xref>], with limited computing and storage resources. Moreover, many variants have been proposed, including the counting Bloom filter (CBF) [<xref ref-type="bibr" rid="pone.0209159.ref012">12</xref>] and its improvements [<xref ref-type="bibr" rid="pone.0209159.ref013">13</xref>–<xref ref-type="bibr" rid="pone.0209159.ref014">14</xref>], the compressed Bloom filter[<xref ref-type="bibr" rid="pone.0209159.ref015">15</xref>], the spectral Bloom filter[<xref ref-type="bibr" rid="pone.0209159.ref016">16</xref>], the dynamic Bloom filter [<xref ref-type="bibr" rid="pone.0209159.ref017">17</xref>], the Cuckoo Filter[<xref ref-type="bibr" rid="pone.0209159.ref018">18</xref>], and the parallel BFs (PBF-HT and PBF-BF) [<xref ref-type="bibr" rid="pone.0209159.ref019">19</xref>, <xref ref-type="bibr" rid="pone.0209159.ref020">20</xref>].</p>
<p>The BF can perform well and obtain a low false positive probability (FPP) only when the hash randomly and uniformly disperses the data, and usually, string hash functions [<xref ref-type="bibr" rid="pone.0209159.ref021">21</xref>] are the default choices. Regardless of the data format, the string hash takes the input as a 1-dimensional string, rather than its original format, and iteratively computes every character to obtain a random integer. To better scatter the data into different places and reduce the FPP, multiple different string hashes are usually selected. To project numerical vectors with high dimensions in their original formats, LshBFs [<xref ref-type="bibr" rid="pone.0209159.ref022">22</xref>–<xref ref-type="bibr" rid="pone.0209159.ref025">25</xref>] replace the string hashes with a uniform locality sensitive hashing (LSH) [<xref ref-type="bibr" rid="pone.0209159.ref026">26</xref>]. However, since the LSH gathers the data around the mean, LshBFs are more suitable for approximate nearest neighbours queries, rather than membership queries.</p>
<p>When the inputs are numerical vectors with high dimensions, this paper proposes dealing with them in their original formats other than strings. First, a unified prime BKDERhash [<xref ref-type="bibr" rid="pone.0209159.ref027">27</xref>] function family, denoted as Prime-HD-BKDERhash, is proposed to substitute for multiple different string hashes. Meanwhile, information entropy is introduced in the BF to verify the randomness and uniformity of the data mapped by the Prime-HD-BKDERhash. Next, by combining the unified Prime-HD-BKDERhash with a counter array, a new BF called P-HDBF is established to store and retrieve the memberships of the big data set. The theoretical analysis and experiments show that the Prime-HD-BKDERhash can disperse elements more effectively than the string hashes, and the P-HDBF is more suitable to represent and query the numerical vectors of a big data set in high-dimensional spaces, which has low space-time costs. Compared with the PBF-HT and PBF-BF, the P-HDBF possesses low false detection rates, low query delays and low space requirements. The advantages of the constant query delay and low space-time costs make the P-HDBF more appropriate for some engineering applications with constrained computing and storage resources, such as distinguish the nuances of the graphics and images.</p>
<p>The remainder of this paper is organized as follows. Related works are described in section 2. The design of Bloom filter and our structure are presented in section 3. The theoretical analyses and proofs are in Sections 4 and 5. Section 6 presents the related performance evaluation and experiments. Section 7 presents the study’s conclusions.</p>
</sec>
<sec id="sec002">
<title>2. Related work</title>
<p>This section provides a brief survey related to the Bloom filter designs and its variants that are suitable for element deletion and multi-dimensional vectors.</p>
<p>A Bloom filter [<xref ref-type="bibr" rid="pone.0209159.ref001">1</xref>] utilities a slightly array to store a big data set. This filter uses the mappings of multiple string hashes to answer whether a query is member of the set with a small false positive probability or not. To support element deletion, the counting Bloom filter (CBF) [<xref ref-type="bibr" rid="pone.0209159.ref012">12</xref>] proves that a 4-bit counter array will be sufficient to defend against overflows brought by element deletion. The FPP, array size and cardinality of the BF have been discussed in [<xref ref-type="bibr" rid="pone.0209159.ref028">28</xref>–<xref ref-type="bibr" rid="pone.0209159.ref030">30</xref>]. The variable incremental counting Bloom filter (VI-CBF) [<xref ref-type="bibr" rid="pone.0209159.ref031">31</xref>] increases the counter by a variable increment rather than the unaltered increment to reduce memory costs. Moreover, with the same counter width, the query in VI-CBF can get a more complete answer than in CBF. The Cuckoo filter [<xref ref-type="bibr" rid="pone.0209159.ref018">18</xref>] consists of an array of buckets where each item has two candidate buckets. The filter computes every item's two fingerprints and bucket positions using hash functions <italic>h</italic><sub>1</sub>(<italic>x</italic>) = <italic>h</italic>(<italic>x</italic>) and <italic>h</italic><sub>2</sub>(<italic>x</italic>) = <italic>h</italic><sub>1</sub>(<italic>x</italic>)⊕<italic>h</italic> (<italic>h</italic> is x's fingerprint). The lookup procedure checks both buckets to see if either one contains the query to determine the membership. Since the insert procedure will continuously relocate existing fingerprints to their alternatives until no more buckets can be allocated, it efficiently reduces the memory costs but results in a long computational time.</p>
<p>Bloom-1 [<xref ref-type="bibr" rid="pone.0209159.ref032">32</xref>] achieves a reduced query overhead at the cost of a higher FPP for a given memory size. Reviriego [<xref ref-type="bibr" rid="pone.0209159.ref033">33</xref>] provides a correct analysis of Bloom-1 and gives out an exact FPP. For the fixed FPP and cardinality of a dataset, the spaces that a BF required are determined. Once a number of extra elements are added in, the FPP will increase quickly. Therefore, the traditional BF is suitable for static sets. The Spectral BF [<xref ref-type="bibr" rid="pone.0209159.ref016">16</xref>] and Dynamic BF (DBF) [<xref ref-type="bibr" rid="pone.0209159.ref017">17</xref>] extend the BF to multi-set and dynamic sets, respectively. To determine which BF an element belongs to in cloud environment, Bloofi [<xref ref-type="bibr" rid="pone.0209159.ref034">34</xref>] organizes different BFs in a hierarchical index structure similar to a B+ tree and the FPP of the hierarchical Bloofi is discussed in [<xref ref-type="bibr" rid="pone.0209159.ref035">35</xref>].</p>
<p>These BFs recognize the inputs as 1-dimensional strings. PBF [<xref ref-type="bibr" rid="pone.0209159.ref020">20</xref>], PBF-HT and PBF-BF [<xref ref-type="bibr" rid="pone.0209159.ref021">21</xref>] have been developed to store and query multi-dimensional elements. The PBF consists of multiple parallel standard BFs, and each standard BF represents an attribute. Due to the destruction of the integrity of the attributes, the PBF generates a high FPP. Furthermore, to reduce the FPP, the PBF-HT (PBF-BF) adds a hash table (a check BF) to the PBF. Let <italic>d</italic> be the number of dimensions, let <italic>m</italic><sub>1</sub> and <italic>m</italic><sub>2</sub> be the sizes of the array of the BF and the HT (or the checkBF), and let <italic>k</italic><sub>1</sub> and <italic>k</italic><sub>2</sub> be numbers of hash functions of the PBF and the HT (or the check BF), respectively. The memory cost and query delay of the PBF-BF (or PBF-HT) are <italic>dm</italic><sub>1</sub>+<italic>m</italic><sub>2</sub> and <italic>k</italic><sub>1</sub><italic>d</italic>+<italic>k</italic><sub>2</sub>, respectively. Both of them grow linearly as dimensions increase and result in huge memory wastes and query delays. Rather than applying multiple different string hashes to map the inputs into different integers, the LshBF schemes [<xref ref-type="bibr" rid="pone.0209159.ref022">22</xref>–<xref ref-type="bibr" rid="pone.0209159.ref025">25</xref>] apply locality sensitive hashing (LSH) [<xref ref-type="bibr" rid="pone.0209159.ref026">26</xref>] functions to directly transform high-dimensional vectors into serial real numbers by performing the dot product with the input dimensions and mapping similar vectors in the Euclidean space to near location(s). The LSH avoids “dimensional disasters” but results in a high FPP when querying memberships. To reduce the FPP, the LshBF-BF [<xref ref-type="bibr" rid="pone.0209159.ref023">23</xref>] adds a verification BF to further disperse vectors. According to the central limited theorem [<xref ref-type="bibr" rid="pone.0209159.ref036">36</xref>], the LSH shrinks all elements of the set around the mean. For example, when the LSH satisfies the standard normal distribution, approximately 68.5% of the elements gather between the negative and positive variance after mapping, which makes it more suitable for approximate nearest neighbours search.</p>
</sec>
<sec id="sec003">
<title>3. Methods and structure</title>
<sec id="sec004">
<title>3.1 Standard Bloom filter and Counter Bloom filter</title>
<p><bold>Definition 1.</bold> Bloom filter (BF) <bold>[<xref ref-type="bibr" rid="pone.0209159.ref001">1</xref>]</bold>. A Bloom filter contains <italic>k</italic> independent string hash functions <italic>h</italic><sub><italic>j</italic></sub>(<italic>j</italic> = 1,…,<italic>k</italic>) and an array of <italic>m</italic> bits initiated to 0. By projecting <italic>k</italic> hashes, the BF stores <italic>n</italic> elements of a set <italic>S</italic> (<italic>V</italic><sub>1</sub>,<italic>V</italic><sub>2</sub>…<italic>V</italic><sub><italic>n</italic></sub>) into the bit array. For <italic>h</italic><sub><italic>j</italic></sub> (<italic>j</italic> = 1,…,<italic>k</italic>) and <italic>V</italic><sub><italic>i</italic></sub>(<italic>i</italic>≤<italic>n</italic>), the bit <italic>h</italic><sub><italic>j</italic></sub>(<italic>V</italic><sub><italic>i</italic></sub>)%<italic>m</italic> is set to 1. A bit can be set to 1 multiple times, but only the first change has an effect. Given a query <italic>q</italic>, if <italic>h</italic><sub><italic>j</italic></sub>(<italic>q</italic>)%<italic>m</italic> = 1 for all <italic>h</italic><sub><italic>j</italic></sub> (<italic>j</italic> = 1,…,<italic>k</italic>), the <italic>q</italic> is accepted as a member of <italic>S</italic> with a false positive probability (FPP).</p>
<p>The BF assumes that each <italic>h</italic><sub><italic>j</italic></sub> (<italic>j</italic> = 1,…,<italic>k</italic>) can randomly and uniformly map elements. Usually, <italic>h</italic><sub><italic>j</italic></sub> is a string hash [<xref ref-type="bibr" rid="pone.0209159.ref021">21</xref>], such as sax_hash and RSHash. By repeatedly iterating every character of <italic>V</italic><sub><italic>i</italic></sub>, <italic>h</italic><sub><italic>j</italic></sub> obtains an integer in the range of [0−(2<sup>31</sup>-1)] (32 bits length) as the random hash fingerprint of <italic>V</italic><sub><italic>i</italic></sub>. For example, given two vectors <italic>X</italic>(357,246,369) and <italic>Y</italic>(468,369,157), the sax_hash function (<italic>h</italic><sub>1</sub>) uses ASCII codes of characters '3','5','7',',','2'… of <italic>X</italic> to iteratively compute a random integer. Then, the counter <italic>h</italic><sub>1</sub>(<italic>X</italic>)%<italic>m</italic> is added with 1, as shown in <xref ref-type="fig" rid="pone.0209159.g001">Fig 1</xref>.</p>
<fig id="pone.0209159.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Bloom filter and counting Bloom filter.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g001" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec005">
<title>3.2 Prime high dimensional Bloom filter</title>
<p>To address numerical vectors with high dimensions in their original formats other than strings, a new uniform hash function family, denoted as Prime_HD_BKDRHash, is proposed. Based on the unified Prime_HD_BKDRHash and a counter array, a new BF called P-HDBF is built, as shown in <xref ref-type="fig" rid="pone.0209159.g002">Fig 2</xref>.</p>
<fig id="pone.0209159.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g002</object-id>
<label>Fig 2</label>
<caption>
<title>P-HDBF and prime_HDBKDRHash.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g002" xlink:type="simple"/>
</fig>
<p><bold>(1) Prime_HD_BKDRHash.</bold> It originates from the BKDRHash function [<xref ref-type="bibr" rid="pone.0209159.ref027">27</xref>] and prime numbers. Given a prime number set <italic>P</italic> = [3,5,7,11,13,17…](except of 2) and a <italic>d</italic> dimensional numerical vector <italic>V</italic>(<italic>v</italic><sub>1</sub>,…,<italic>v</italic><sub><italic>d</italic></sub>), Prime_HD_BKDRHash considers <italic>V</italic> as a <italic>d</italic> dimensional vector. By iteratively computing <italic>h</italic><sup><italic>p</italic></sup> = <italic>S</italic><sub><italic>i</italic></sub> = ∏<italic>p</italic><sub><italic>i</italic>-1</sub>⋅<italic>S</italic><sub><italic>i</italic>−1</sub>+<italic>v</italic><sub><italic>i</italic></sub> (<italic>i</italic> = 1…<italic>d</italic>), <italic>d</italic> dimensions contribute to the last hash value. Although the <italic>jth</italic> operation and the (<italic>j</italic>+1)<italic>th</italic> operation are same, the corresponding prime numbers are different. Therefore, <italic>h</italic><sub><italic>j</italic></sub>(<italic>V</italic>) and <italic>h</italic><sub><italic>j</italic>+1</sub>(<italic>V</italic>) will get different hash values (details in section 4.1).</p>
<p><bold>(2)A counter array (CA).</bold> The array of P-HDBF contains <italic>m</italic> counters and each counter occupies 4 bits, which is enough to defend against the FNP brought by deleting elements [<xref ref-type="bibr" rid="pone.0209159.ref012">12</xref>]. When <italic>k</italic> random integers are calculated by <italic>k</italic> Prime_HD_BKDRHash functions, the counter <italic>h</italic><sub><italic>j</italic></sub>(<italic>V</italic>)%<italic>m</italic>(1≤<italic>j</italic>≤<italic>k</italic>) of the CA is added to 1.</p>
</sec>
</sec>
<sec id="sec006">
<title>4. Theoretical analysis</title>
<p>The BF structure can work well only when the hashes can randomly and uniformly project all elements, since it is the basis of the BF. Therefore, this section will discuss the hash family- Prime_H-D_BKDRHash which is based on BKDRHash [<xref ref-type="bibr" rid="pone.0209159.ref027">27</xref>], and demonstrate why it is effective in the projection and query of high-dimensional vectors. The definition, proof and algorithm are shown as follows.</p>
<sec id="sec007">
<title>4.1 Prime_HD_ BKDRHash</title>
<p><bold>Definition 2.</bold> A family <italic>H</italic><sup><italic>p</italic></sup> = {<italic>h</italic><sup><italic>p</italic></sup>:<italic>R</italic><sup><italic>d</italic></sup>→<italic>U</italic>} of functions is called a prime high-dimensional BKDRHash (Prime_HD_BKDRHash), if ∀<italic>V</italic>∈<italic>R</italic><sup><italic>d</italic></sup>,<italic>V</italic>(<italic>v</italic><sub>1</sub>,…,<italic>v</italic><sub><italic>d</italic></sub>) and a prime number set <italic>P</italic>(<italic>p</italic><sub>1</sub>,…,<italic>p</italic><sub><italic>l</italic></sub>)(<italic>l</italic>∈∞) (without 2), such that <italic>h</italic><sup><italic>p</italic></sup> = <italic>S</italic><sub><italic>i</italic></sub> = ∏<italic>p</italic><sub><italic>i</italic>-1</sub>⋅<italic>S</italic><sub><italic>i</italic>−1</sub>+<italic>v</italic><sub><italic>i</italic></sub> (<italic>i</italic> = 1…<italic>d</italic>).</p>
<p><bold>Theorem 1.</bold> By <italic>h</italic><sup><italic>p</italic></sup> mapping, all vectors <italic>V</italic><sub><italic>j</italic></sub>(<italic>v</italic><sub>1</sub>,…,<italic>v</italic><sub><italic>d</italic></sub>) with <italic>d</italic> dimensions in a set will be randomly and uniformly projected to different integers.</p>
<p><bold>Proof.</bold> Since <italic>h</italic><sup><italic>p</italic></sup> = <italic>S</italic><sub><italic>i</italic></sub> = ∏<italic>p</italic><sub><italic>i</italic>-1</sub>⋅<italic>S</italic><sub><italic>i</italic>−1</sub>+<italic>v</italic><sub><italic>i</italic></sub> (<italic>i</italic> = 1…<italic>d</italic>), then
<disp-formula id="pone.0209159.e001">
<alternatives>
<graphic id="pone.0209159.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e001" xlink:type="simple"/>
<mml:math display="block" id="M1">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>S</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1.25em"/><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1.25em"/><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(1)</label>
</disp-formula>
Let <italic>p</italic><sub><italic>i</italic></sub>&lt;2<sup>32</sup>, 0&lt;<italic>v</italic><sub><italic>i</italic></sub>≪2<sup>32</sup> (<italic>i</italic> = 1,…,<italic>d</italic>), <italic>α</italic><sub><italic>d</italic></sub> = 1 and <italic>α</italic><sub><italic>d</italic>−1</sub> = <italic>p</italic><sub><italic>d</italic></sub>⋅<italic>α</italic><sub><italic>d</italic></sub>. For any <italic>i</italic> = 1,…,<italic>d</italic>−1, <italic>α</italic><sub><italic>i</italic></sub> = <italic>p</italic><sub><italic>i</italic>+1</sub>⋅<italic>α</italic><sub><italic>i</italic>+1</sub>&gt;0 and <italic>α</italic><sub><italic>j</italic></sub>&gt;<italic>α</italic><sub><italic>i</italic></sub>(<italic>j</italic>&gt;i). If <italic>α</italic><sub><italic>i</italic></sub>&lt;2<sup>32</sup> and any <italic>α</italic><sub><italic>j</italic></sub>⋅<italic>v</italic><sub><italic>j</italic></sub>&gt;2<sup>32</sup> (<italic>j</italic>&gt;<italic>i</italic>), <italic>α</italic><sub><italic>j</italic></sub>⋅<italic>v</italic><sub><italic>j</italic></sub> overflows, and the overflow part will be discarded by the 32-bit CPU. Since <italic>p</italic><sub><italic>j</italic></sub>∈<italic>P</italic> (without 2), <italic>p</italic><sub><italic>i</italic></sub> is an odd number, and the multiplication of odd numbers is still an odd number. Since ∃<italic>x</italic>'∈<italic>N</italic>, <inline-formula id="pone.0209159.e002"><alternatives><graphic id="pone.0209159.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e002" xlink:type="simple"/><mml:math display="inline" id="M2"><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>x</mml:mi><mml:mo>'</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>. Meanwhile, <italic>v</italic><sub><italic>j</italic></sub>∈<italic>N</italic> and 0&lt;<italic>v</italic><sub><italic>i</italic></sub>≪2<sup>32</sup>, therefore
<disp-formula id="pone.0209159.e003">
<alternatives>
<graphic id="pone.0209159.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e003" xlink:type="simple"/>
<mml:math display="block" id="M3">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.5em"/><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>x</mml:mi><mml:mo>'</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mo>'</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.5em"/><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>x</mml:mi><mml:mo>'</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.5em"/><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(2)</label>
</disp-formula>
If <italic>α</italic><sub><italic>i</italic></sub>&lt;2<sup>32</sup> and <italic>α</italic><sub><italic>i</italic>−1</sub> = <italic>p</italic><sub><italic>i</italic></sub>⋅<italic>α</italic><sub><italic>i</italic></sub>&gt;2<sup>32</sup>, there always exists <italic>z</italic><sub><italic>i</italic>−1</sub> = 2<italic>x</italic>+1(<italic>x</italic>∈<italic>N</italic>), which makes
<disp-formula id="pone.0209159.e004">
<alternatives>
<graphic id="pone.0209159.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e004" xlink:type="simple"/>
<mml:math display="block" id="M4">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="4.75em"/><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo>
</mml:math>
</alternatives>
<label>(3)</label>
</disp-formula>
and
<disp-formula id="pone.0209159.e005">
<alternatives>
<graphic id="pone.0209159.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e005" xlink:type="simple"/>
<mml:math display="block" id="M5">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="4.75em"/><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="4.75em"/><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(4)</label>
</disp-formula>
The same operations are applied on other fields from <italic>α</italic><sub>1</sub>⋅<italic>v</italic><sub>1</sub> to <italic>α</italic><sub><italic>i</italic>−3</sub>⋅<italic>v</italic><sub><italic>i</italic>−3</sub>. For <italic>v</italic><sub><italic>i</italic></sub>∈<italic>N</italic>, all 2<sup>32</sup>⋅<italic>v</italic><sub><italic>i</italic>−1</sub> and <italic>p</italic><sub><italic>j</italic></sub>⋅…⋅<italic>p</italic><sub><italic>i</italic>−1</sub>⋅2<sup>32</sup>⋅<italic>v</italic><sub><italic>j</italic></sub>(1≤<italic>j</italic>&lt;<italic>i</italic>−2) will be discarded by the 32-bit CPU due to overflow. Then,
<disp-formula id="pone.0209159.e006">
<alternatives>
<graphic id="pone.0209159.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e006" xlink:type="simple"/>
<mml:math display="block" id="M6">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>S</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:mo>…</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(5)</label>
</disp-formula>
If <italic>p</italic><sub><italic>j</italic></sub>…⋅<italic>p</italic><sub><italic>i</italic>−1</sub>⋅z<sub><italic>i</italic>-1</sub> = 2<sup>32</sup>+<italic>z</italic>(<italic>j</italic>&lt;<italic>i</italic>), the CPU will iteratively discard the overflows. After multiple iterations,
<disp-formula id="pone.0209159.e007">
<alternatives>
<graphic id="pone.0209159.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e007" xlink:type="simple"/>
<mml:math display="block" id="M7">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>S</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>v</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>'</mml:mo></mml:mrow></mml:msubsup></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo>
</mml:math>
</alternatives>
<label>(6)</label>
</disp-formula>
where, for example, <italic>p</italic><sub><italic>i</italic></sub>∈<italic>P</italic>, <italic>z</italic><sub><italic>i</italic>−1</sub> = 2<italic>x</italic>+1(<italic>x</italic>∈<italic>N</italic>), <italic>z</italic><sub>1</sub> = <italic>p</italic><sub>1</sub>⋅<italic>p</italic><sub>2</sub>…⋅<italic>p</italic><sub><italic>l</italic></sub>⋅<italic>z</italic><sub><italic>i</italic>−1</sub> <italic>z</italic><sub>2</sub> = <italic>p</italic><sub>2</sub>…⋅<italic>p</italic><sub><italic>l</italic></sub>⋅<italic>z</italic><sub>i−1</sub>. Therefore, <italic>p</italic><sub>1</sub><italic>p</italic><sub>2</sub>…<italic>z</italic><sub><italic>i</italic>−1</sub>≠<italic>p</italic><sub>2</sub>…<italic>z</italic><sub><italic>i</italic>−1</sub>≠<italic>p</italic><sub><italic>i</italic>−2</sub><italic>z</italic><sub><italic>i</italic>−1</sub>≠<italic>z</italic><sub><italic>i</italic>−1</sub>≠<italic>α</italic><sub>1</sub> ≠ <italic>β</italic><sub><italic>j</italic></sub>…&lt;2<sup>32</sup>. Next, according to congruence theory [<xref ref-type="bibr" rid="pone.0209159.ref037">37</xref>],
<disp-formula id="pone.0209159.e008">
<alternatives>
<graphic id="pone.0209159.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e008" xlink:type="simple"/>
<mml:math display="block" id="M8">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>S</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.75em"/><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(7)</label>
</disp-formula></p>
<p><bold>Worst case:</bold> Since <italic>p</italic><sub><italic>i</italic></sub>∈<italic>P</italic> (without 2), <italic>p</italic><sub><italic>i</italic></sub> is an odd number, and the multiplication of odd numbers is still an odd number. Let <italic>n</italic><sub><italic>i</italic></sub> be positive integers. Then, <inline-formula id="pone.0209159.e009"><alternatives><graphic id="pone.0209159.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e009" xlink:type="simple"/><mml:math display="inline" id="M9"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209159.e010"><alternatives><graphic id="pone.0209159.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e011"><alternatives><graphic id="pone.0209159.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>. Therefore,
<disp-formula id="pone.0209159.e012">
<alternatives>
<graphic id="pone.0209159.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e012" xlink:type="simple"/>
<mml:math display="block" id="M12">
<mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(8)</label>
</disp-formula>
For <italic>S</italic><sub><italic>d</italic></sub>, if 2<italic>n</italic><sub><italic>i</italic></sub>≥2<sup>32</sup>, the CPU will discard the overflow part. At worst, for all <italic>i</italic>, 2<italic>n</italic><sub><italic>i</italic></sub> = <italic>k</italic><sub><italic>i</italic></sub>2<sup>32</sup>(<italic>k</italic><sub><italic>i</italic></sub>∈<italic>N</italic>), then <italic>S</italic><sub><italic>d</italic></sub> = <italic>v</italic><sub>1</sub>+<italic>v</italic><sub>2</sub>+…+<italic>v</italic><sub><italic>i</italic></sub>+…+<italic>v</italic><sub><italic>d</italic></sub>.</p>
<p>The function <italic>S</italic><sub><italic>d</italic></sub>%<italic>m</italic> maps the <italic>S</italic><sub><italic>d</italic></sub> into the counter array, according to congruence theory [<xref ref-type="bibr" rid="pone.0209159.ref037">37</xref>].
<disp-formula id="pone.0209159.e013">
<alternatives>
<graphic id="pone.0209159.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e013" xlink:type="simple"/>
<mml:math display="block" id="M13">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>S</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.75em"/><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(9)</label>
</disp-formula>
From formulas (<xref ref-type="disp-formula" rid="pone.0209159.e008">7</xref>) and (<xref ref-type="disp-formula" rid="pone.0209159.e013">9</xref>), even in the worst case, every dimension <italic>v</italic><sub><italic>i</italic></sub> contributes to <italic>S</italic><sub><italic>d</italic></sub>%<italic>m</italic>. In fact, from formula (<xref ref-type="disp-formula" rid="pone.0209159.e008">7</xref>), all of the coefficients are odd numbers and they are different. For a well-selected <italic>m</italic>, different <italic>v</italic><sub><italic>i</italic></sub> will have different contributions to the final result, and the change of a <italic>v</italic><sub><italic>i</italic></sub> will change <italic>S</italic><sub><italic>d</italic></sub>%<italic>m</italic>. Therefore, <italic>h</italic><sup><italic>p</italic></sup> satisfies the avalanche effect of hash functions [<xref ref-type="bibr" rid="pone.0209159.ref038">38</xref>] and can be regard as a uniform hash function.</p>
<p><bold>Lemma 1.</bold> For a vector <italic>V</italic>, functions <inline-formula id="pone.0209159.e014"><alternatives><graphic id="pone.0209159.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e014" xlink:type="simple"/><mml:math display="inline" id="M14"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e015"><alternatives><graphic id="pone.0209159.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e015" xlink:type="simple"/><mml:math display="inline" id="M15"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> are independently selected from the Prime_HD_BKDRhash family. There exist <inline-formula id="pone.0209159.e016"><alternatives><graphic id="pone.0209159.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e016" xlink:type="simple"/><mml:math display="inline" id="M16"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e017"><alternatives><graphic id="pone.0209159.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e017" xlink:type="simple"/><mml:math display="inline" id="M17"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>≠</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<p><bold>Explain.</bold> For any two hash functions <inline-formula id="pone.0209159.e018"><alternatives><graphic id="pone.0209159.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e018" xlink:type="simple"/><mml:math display="inline" id="M18"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e019"><alternatives><graphic id="pone.0209159.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e019" xlink:type="simple"/><mml:math display="inline" id="M19"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209159.e020"><alternatives><graphic id="pone.0209159.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e020" xlink:type="simple"/><mml:math display="inline" id="M20"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. For simplicity, let <italic>d</italic> = 3, <italic>V</italic>(<italic>v</italic><sub>1</sub>,<italic>v</italic><sub>2</sub>,<italic>v</italic><sub>3</sub>), <inline-formula id="pone.0209159.e021"><alternatives><graphic id="pone.0209159.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e021" xlink:type="simple"/><mml:math display="inline" id="M21"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e022"><alternatives><graphic id="pone.0209159.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e022" xlink:type="simple"/><mml:math display="inline" id="M22"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. From formula (<xref ref-type="disp-formula" rid="pone.0209159.e001">1</xref>),
<disp-formula id="pone.0209159.e023">
<alternatives>
<graphic id="pone.0209159.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e023" xlink:type="simple"/>
<mml:math display="block" id="M23">
<mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo>
</mml:math>
</alternatives>
<label>(10)</label>
</disp-formula>
where <italic>p</italic><sub>1</sub>&lt;<italic>p</italic><sub>2</sub>&lt;<italic>p</italic><sub>3</sub>&lt;<italic>p</italic><sub>4</sub>&lt;<italic>p</italic><sub>5</sub>&lt;<italic>p</italic><sub>6</sub> and <italic>p</italic><sub><italic>i</italic></sub>∈<italic>P</italic>. Therefore, <inline-formula id="pone.0209159.e024"><alternatives><graphic id="pone.0209159.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e024" xlink:type="simple"/><mml:math display="inline" id="M24"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mo>≠</mml:mo><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e025"><alternatives><graphic id="pone.0209159.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e025" xlink:type="simple"/><mml:math display="inline" id="M25"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<p>Let <italic>q</italic><sub>1</sub> and <italic>q</italic><sub>2</sub> be quotients and <italic>r</italic><sub>1</sub> and <italic>r</italic><sub>2</sub> be remainders. <inline-formula id="pone.0209159.e026"><alternatives><graphic id="pone.0209159.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e026" xlink:type="simple"/><mml:math display="inline" id="M26"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e027"><alternatives><graphic id="pone.0209159.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e027" xlink:type="simple"/><mml:math display="inline" id="M27"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> mod <italic>m</italic> are
<disp-formula id="pone.0209159.e028">
<alternatives>
<graphic id="pone.0209159.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e028" xlink:type="simple"/>
<mml:math display="block" id="M28">
<mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(11)</label>
</disp-formula>
For a proper <italic>m</italic> and <italic>r</italic><sub>1</sub>≠<italic>r</italic><sub>2</sub>, <inline-formula id="pone.0209159.e029"><alternatives><graphic id="pone.0209159.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e029" xlink:type="simple"/><mml:math display="inline" id="M29"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e030"><alternatives><graphic id="pone.0209159.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e030" xlink:type="simple"/><mml:math display="inline" id="M30"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> can scatter vectors into different positions. Without the loss of generality, 3 dimensions expand to <italic>d</italic> dimensions and <inline-formula id="pone.0209159.e031"><alternatives><graphic id="pone.0209159.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e031" xlink:type="simple"/><mml:math display="inline" id="M31"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e032"><alternatives><graphic id="pone.0209159.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e032" xlink:type="simple"/><mml:math display="inline" id="M32"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> spread to <inline-formula id="pone.0209159.e033"><alternatives><graphic id="pone.0209159.e033g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e033" xlink:type="simple"/><mml:math display="inline" id="M33"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209159.e034"><alternatives><graphic id="pone.0209159.e034g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e034" xlink:type="simple"/><mml:math display="inline" id="M34"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. For well selected prime numbers, the worst case of formula (<xref ref-type="disp-formula" rid="pone.0209159.e013">9</xref>) can be avoided, since <inline-formula id="pone.0209159.e035"><alternatives><graphic id="pone.0209159.e035g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e035" xlink:type="simple"/><mml:math display="inline" id="M35"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <italic>r</italic><sub><italic>i</italic></sub>≠<italic>r</italic><sub><italic>j</italic></sub>,
<disp-formula id="pone.0209159.e036">
<alternatives>
<graphic id="pone.0209159.e036g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e036" xlink:type="simple"/>
<mml:math display="block" id="M36">
<mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mi>d</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mi>d</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:msubsup><mml:mi>%</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi mathvariant="normal">*</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>%</mml:mi><mml:mi>m</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo>
</mml:math>
</alternatives>
<label>(12)</label>
</disp-formula></p>
</sec>
<sec id="sec008">
<title>4.2 Algorithm</title>
<p>From the above discussion, the Prime_HD_BKDRhash functions can randomly and uniformly map high-dimensional vectors to integers and Algorithms 1 combined with <xref ref-type="fig" rid="pone.0209159.g002">Fig 2</xref> demonstrate the working process.</p>
<p specific-use="line"><bold>Algorithm 1</bold>.</p>
<p specific-use="line">unsigned int Prime_HD_BKDRHash (int* V, int k, int d)</p>
<p specific-use="line">{</p>
<p specific-use="line">1. unsigned int prime_set = [3,5,7,11,13,17 …];</p>
<p specific-use="line">2. unsigned int S = 0, i = 0;</p>
<p specific-use="line">3. while (*V)</p>
<p specific-use="line">4.         S = prime_set [k*d+i++] *S+ (*V++);</p>
<p specific-use="line">5. return S&amp;0x0FFFFFFF;</p>
<p specific-use="line">}</p>
<p>The input parameters contain the vector <italic>V</italic>, dimensions <italic>d</italic> and the <italic>kth</italic> hash function. After <italic>d</italic> loops, lines 3 and 4 of Algorithm 1 obtain <inline-formula id="pone.0209159.e037"><alternatives><graphic id="pone.0209159.e037g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e037" xlink:type="simple"/><mml:math display="inline" id="M37"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>k</mml:mi><mml:mi>p</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>∏</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. By performing a bitwise AND on <italic>S</italic><sub><italic>i</italic></sub> and 0x0FFFFFFF, the <italic>kth</italic> Prime_HD_BKDRHash transforms the vector <italic>V</italic> into an integer that ranges from [0−(2<sup>32</sup>−1)]. Since different hash functions adopt different prime numbers, the return integers are different.</p>
</sec>
</sec>
<sec id="sec009">
<title>5. Performances</title>
<p>In section 4, we have demonstrated that the Prime_HD_ BKDRHash can randomly and uniformly scatter the high-dimensional vectors of a set to integers in the range of 0 to 2<sup>32</sup>−1. Therefore, the P-HDBF satisfies the theory of the BF, including all parameters and their relationships.</p>
<sec id="sec010">
<title>5.1 False positive probability (FPP), m, n, k and false negative probability (FNP)</title>
<p><bold>FPP.</bold> Let there be <italic>k</italic> hash functions, a counter array of size <italic>m</italic> and a set containing <italic>n</italic> vectors with <italic>d</italic> numerical dimensions. After the <italic>n</italic> vectors are mapped onto the P-HDBF, the false positive probability of the P-HDBF is [<xref ref-type="bibr" rid="pone.0209159.ref015">15</xref>].</p>
<disp-formula id="pone.0209159.e038">
<alternatives>
<graphic id="pone.0209159.e038g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e038" xlink:type="simple"/>
<mml:math display="block" id="M38">
<mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>P</mml:mi><mml:mo>−</mml:mo><mml:mi>H</mml:mi><mml:mi>D</mml:mi><mml:mi>B</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mi>‑</mml:mi><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>≈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:mfrac></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(13)</label>
</disp-formula>
<p><bold>Counters.</bold> For fixed <italic>k</italic>, <italic>n</italic> and FPP, <bold>t</bold>he counters that the P-HDBF requires are
<disp-formula id="pone.0209159.e039">
<alternatives>
<graphic id="pone.0209159.e039g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e039" xlink:type="simple"/>
<mml:math display="block" id="M39">
<mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>k</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">ln</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>P</mml:mi><mml:mo>−</mml:mo><mml:mi>H</mml:mi><mml:mi>D</mml:mi><mml:mi>B</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow/><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(14)</label>
</disp-formula></p>
<p><bold>Maximum cardinality.</bold> For fixed <italic>m</italic>,<italic>k</italic> and FPP, the maximum number of the vectors the P-HDBF can represent is
<disp-formula id="pone.0209159.e040">
<alternatives>
<graphic id="pone.0209159.e040g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e040" xlink:type="simple"/>
<mml:math display="block" id="M40">
<mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">ln</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi mathvariant="normal">ln</mml:mi><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:mfrac></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:mfrac><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(15)</label>
</disp-formula></p>
<p><bold>Minimum number of hash functions.</bold> For fixed <italic>m</italic>, <italic>n</italic> and FPP, the minimum number of hash functions is
<disp-formula id="pone.0209159.e041">
<alternatives>
<graphic id="pone.0209159.e041g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e041" xlink:type="simple"/>
<mml:math display="block" id="M41">
<mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi mathvariant="normal">min</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">ln</mml:mi><mml:mspace width="0.25em"/><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mi>m</mml:mi><mml:mi>n</mml:mi></mml:mfrac><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(16)</label>
</disp-formula></p>
<p><bold>False negative probability (FNP).</bold> The FNP of the P-HDBF is
<disp-formula id="pone.0209159.e042">
<alternatives>
<graphic id="pone.0209159.e042g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e042" xlink:type="simple"/>
<mml:math display="block" id="M42">
<mml:mrow><mml:mi>f</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>P</mml:mi><mml:mo>−</mml:mo><mml:mi>H</mml:mi><mml:mi>D</mml:mi><mml:mi>B</mml:mi><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(17)</label>
</disp-formula></p>
</sec>
<sec id="sec011">
<title>5.2 Time complexity</title>
<p>For a hash <italic>h</italic><sub><italic>j</italic></sub> and a query <italic>q</italic>, every numerical dimension <italic>q</italic><sub><italic>i</italic></sub> will participate in the computation. By computing the <italic>k</italic> hashes, the P-HDBF obtains <italic>k</italic> integers. Next, by mapping <italic>h</italic><sub><italic>j</italic></sub>(<italic>q</italic>)%<italic>m</italic>, the P-HDBF checks whether the corresponding <italic>k</italic> counters are greater than or equal to 0. If any counter is 0, we know that the query is not in the set. If all counters are larger than 0, the query is determined as a member of the set with a small FPP. For a set of <italic>n</italic> elements with <italic>d</italic> dimensions, its initialization time complexity is
<disp-formula id="pone.0209159.e043">
<alternatives>
<graphic id="pone.0209159.e043g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e043" xlink:type="simple"/>
<mml:math display="block" id="M43">
<mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(18)</label>
</disp-formula></p>
<p>The time complexity of insertion/deletion/query of a vector is
<disp-formula id="pone.0209159.e044">
<alternatives>
<graphic id="pone.0209159.e044g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e044" xlink:type="simple"/>
<mml:math display="block" id="M44">
<mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(19)</label>
</disp-formula></p>
</sec>
</sec>
<sec id="sec012">
<title>6. Experiment</title>
<sec id="sec013">
<title>6.1. Dataset and setting</title>
<p>To verify the effectiveness of the P-HDBF on high-dimensional numeric vectors, this paper adopts 3 picture datasets, including Colour [<xref ref-type="bibr" rid="pone.0209159.ref039">39</xref>], Sift [<xref ref-type="bibr" rid="pone.0209159.ref040">40</xref>] and Gist [<xref ref-type="bibr" rid="pone.0209159.ref040">40</xref>], used in most experiments. On these datasets, we compare the performances of the P-HDBF with the CBF, PBF-HT and PBF-BF. The CBF is the classical method in all variants and the PBF-HT and PBF-BF support the query of multiple dimensions. The Colour includes 70,000(70K) vectors with 32 dimensions, and the values are expanded to positive integers. The Sift and Gist contain 100,000 (100K) vectors with 128 and 960 dimensions, respectively, and values of dimensions are all positive integers. All query vectors are different from the samples and are set to 10,000(10K). The experiments were conducted on a computer with an Intel Xeon E5-2603 v3 and 16GB RAM.</p>
</sec>
<sec id="sec014">
<title>6.2 Distribution and entropy</title>
<p>The key of the BF is that the data can be randomly and uniformly projected by hash functions. To verify this performance, we first introduce information entropy of the array in the BF after Prime_HD_BKDRHash mapping. Information entropy can describe the randomness of a system, and a larger entropy indicates a greater dispersed state. Let <italic>v</italic>' be the number of the elements allocated in a counter of the array, and <italic>n</italic> and <italic>m</italic> be the size of the set and the array, respectively. Then, the proportion of the vectors allocated in the counter can be calculated by <italic>p</italic>≈<italic>v</italic>'/<italic>kn</italic>, and the entropy of all counters is defined as follows.</p>
<disp-formula id="pone.0209159.e045">
<alternatives>
<graphic id="pone.0209159.e045g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0209159.e045" xlink:type="simple"/>
<mml:math display="block" id="M45">
<mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mi>m</mml:mi></mml:munder><mml:mrow><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mspace width="0.25em"/><mml:mi>p</mml:mi></mml:mrow></mml:mstyle><mml:mo>≈</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mi>m</mml:mi></mml:munder><mml:mrow><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>'</mml:mo><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>'</mml:mo><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow>
</mml:math>
</alternatives>
<label>(20)</label>
</disp-formula>
<p>Let <italic>k</italic> = 6 and <italic>m</italic> = 25<italic>n</italic>. Figs <xref ref-type="fig" rid="pone.0209159.g003">3</xref> and <xref ref-type="fig" rid="pone.0209159.g004">4</xref> display the number of the vectors allocated in different counters (denoted as distribution) and entropies of the P-HDBF and the CBF on the 3 datasets. As <xref ref-type="fig" rid="pone.0209159.g003">Fig 3</xref> shows, the distribution of the P-HDBF is similar to the CBF, which implies that the vectors are uniformly allocated in different counters. <xref ref-type="fig" rid="pone.0209159.g004">Fig 4</xref> shows that the entropy of the P-HDBF is slightly larger than that of the CBF under different samples and dimensions, especially in a high-dimensional space. From the view of the entropy, larger entropy means better discretization and less collision. Figs <xref ref-type="fig" rid="pone.0209159.g003">3</xref> and <xref ref-type="fig" rid="pone.0209159.g004">4</xref> reflect that the Prime_HD_BKDRHash can scatter vectors more randomly and uniformly, especially for the high-dimensional vectors of a big data set (on Gist with d = 960). This implies that the FPP of the query after mapping by the uniform Prime_HD_BKDRHash will be less than that of multiple string hashes. The uniform Prime_HD_BKDRHash can project the numerical vectors as the inputs of the original formats and substitute multiple different string hashes of the BF.</p>
<fig id="pone.0209159.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Number of vectors allocated in different counters of the CBF and the P-HDBF on colour (d = 32), Sift (d = 128) and Gist (d = 960).</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g003" xlink:type="simple"/>
</fig>
<fig id="pone.0209159.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Entropy of the CBF and P-HDBF under different samples and dimensions.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g004" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec015">
<title>6.3 Relationships of the FPP, n, m, d and k</title>
<p>This section will show whether the P-HDBF is consistent with the theory of the Bloom filter, and the indicators include the FPP, n, m, k and their relationships. The CBF, as a classical BF, is applied for comparison with the P-HDBF, and the P-HDBF should show the same tendencies as the CBF. By fixing one or two parameter(s) in turn, Figs <xref ref-type="fig" rid="pone.0209159.g005">5</xref>, <xref ref-type="fig" rid="pone.0209159.g006">6</xref> and <xref ref-type="fig" rid="pone.0209159.g007">7</xref> show the FPPs’ changes with other parameters changing. For the fixed memory costs (m) and the number of the hash functions (k), the increased collision rate causes the FPP growing. Let <italic>m</italic> = 50<italic>k</italic> and <italic>k</italic> = 6. <xref ref-type="fig" rid="pone.0209159.g005">Fig 5</xref> displays the increased tendencies of the FPPs as the cardinality of the set increases, even to 100%.</p>
<fig id="pone.0209159.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g005</object-id>
<label>Fig 5</label>
<caption>
<title>FPPs of the CBF and P-HDBF with an increasing n.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g005" xlink:type="simple"/>
</fig>
<fig id="pone.0209159.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g006</object-id>
<label>Fig 6</label>
<caption>
<title>FPPs of the CBF and the P-HDBF under different k and memory costs.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g006" xlink:type="simple"/>
</fig>
<fig id="pone.0209159.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g007</object-id>
<label>Fig 7</label>
<caption>
<title>FPPs of the CBF and P-HDBF with the memory increase.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g007" xlink:type="simple"/>
</fig>
<p>Then, by fixing memory costs (0.21 MB, 0.28 MB, and 0.35 MB), <xref ref-type="fig" rid="pone.0209159.g006">Fig 6</xref> demonstrates the FPPs as <italic>k</italic> increases on the 3 datasets. For the fixed number of samples (n) and memory costs (m), the number of the hash functions (k) determines the FPP. Firstly, the FPP will decrease as <italic>k</italic> grows and reach to a minimum value, then the increasing collisions will result in a low FPP. With <italic>k</italic> rising, both FPPs sharply decrease, reach a minimum value, and then increase slowly, which is consistent with the theory of the BF.</p>
<p>Lastly, for <italic>k</italic> = 6, <xref ref-type="fig" rid="pone.0209159.g007">Fig 7</xref> displays the similar changes in the FPPs of the CBF and the P-HDBF as <italic>m</italic> increases from 5<italic>n</italic> to 25<italic>n</italic>. For fixed <italic>k</italic> and <italic>n</italic>, the FPP will be decided by memories allocated to them, and a large <italic>m</italic> can effectively reduce the FPPs.</p>
<p>To further observe the performance of the P-HDBF in a high dimensional space, an extra experiment is added. Let <italic>n</italic> = 70<italic>K</italic>(100<italic>K</italic>,100<italic>K</italic>), <italic>k</italic> = 6 and the memory be 0.35 MB. <xref ref-type="fig" rid="pone.0209159.g008">Fig 8</xref> demonstrates the changes of the FPPs with increasing dimensions. The FPPs of the P-HDBF are lower than those of the CBF, especially in certain high dimensional cases.</p>
<fig id="pone.0209159.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g008</object-id>
<label>Fig 8</label>
<caption>
<title>FPPs of the CBF and P-HDBF under different dimensions.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g008" xlink:type="simple"/>
</fig>
<p>For different <italic>m</italic>, <italic>n</italic> and <italic>k</italic>, the FPPs’ changes of the CBF and the P-HDBF are almost the same. Even the performance of the P-HDBF is better than the CBF, which implies that the P-HDBF can replace the CBF to process high-dimensional vectors. Meanwhile, the FPPs’ changes of the P-HDBF are consistent with the theory in section 5. Next, we will continue to compare the performance of the P-HDBF with other methods.</p>
</sec>
<sec id="sec016">
<title>6.4 Compared with other methods</title>
<p>Let <italic>FPP</italic>⊂[0.0001−0.0005], <italic>m</italic> = 25<italic>n</italic> and <italic>k</italic> = 6. This paper compares the memory usages of the CBF, PBF-BF and PBF-HT with the P-HDBF on 3 datasets, as shown in <xref ref-type="fig" rid="pone.0209159.g009">Fig 9</xref>. For the fixed FPP, the CBF and the P-HDBF have memory overheads. However, the memory costs of the PBF-BF and the PBF-HT grow with increased sample sizes and dimensions.</p>
<fig id="pone.0209159.g009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g009</object-id>
<label>Fig 9</label>
<caption>
<title>Memory costs under different samples and dimensions.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g009" xlink:type="simple"/>
</fig>
<p>Figs <xref ref-type="fig" rid="pone.0209159.g010">10</xref> and <xref ref-type="fig" rid="pone.0209159.g011">11</xref> exhibit the average initiation and query time of different schemes under 10K query vectors. Since these schemes need to split all vectors and project them into the storing arrays, the initiation and query times will continue to increase with larger samples and more dimensions. Compared with the PBF-BF and PBF-HT, the CBF and the P-HDBF only require dividing the dimensions and computing the hash values. Therefore, their initiation and query times increase slowly with more dimensions. The initiation time and query delays of the CBF and P-HDBF are far smaller than those of the PBF-BF and PBF-HT.</p>
<fig id="pone.0209159.g010" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g010</object-id>
<label>Fig 10</label>
<caption>
<title>Average initiation time of the PBF-HT, PBF-BF, CBF and P-HDBF with <italic>FPP</italic>⊂[0.0001−0.0005] and <italic>k</italic> = 6.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g010" xlink:type="simple"/>
</fig>
<fig id="pone.0209159.g011" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0209159.g011</object-id>
<label>Fig 11</label>
<caption>
<title>Average query delays of the PBF-HT, PBF-BF,CBF and P-HDBF with <italic>FPP</italic>⊂[0.0001−0.0005] and <italic>k</italic> = 6.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0209159.g011" xlink:type="simple"/>
</fig>
<p>Therefore, for a given FPP and a dataset with high-dimensional vectors, the P-HDBF will be a better choice than the PBF-based schemes by avoiding a long member query delay and huge memory costs.</p>
</sec>
</sec>
<sec id="sec017" sec-type="conclusions">
<title>7. Conclusions</title>
<p>Regardless of the formats of the inputs, the traditional Bloom filters adopt multiple string hashes to implement memberships queries of a big data set. To map the inputs with numerical high dimensions in their original type(s), this paper proposes a uniform Prime_HD_BKDRHash function and establishes a P-HDBF structure, a new Bloom filter, to store and query members of a big data set with numerical dimensions. The unified Prime_HD_BKDRHash can randomly and uniformly project the inputs (other than multiple string hashes) into different integers. The performances and parameters of the P-HDBF have been theoretically discussed. The experiments show that the P-HDBF, as a substitute for the counting Bloom filter in high-dimensional numerical spaces, can obtain excellent data discretization and a good performance. Compared with the methods based on the parallel Bloom filters, the P-HDBF will not increase memory use or query delays as dimensions increase and can be used in applications with limited CPU and memory resources. The P_HDBF can be applied in some applications, such as identify the nuances of pictures.</p>
</sec>
</body>
<back>
<ack>
<p>The authors would like to thank Matthijs Douze and Cordelia Schmid for their data sources, data and interpretation of data (<ext-link ext-link-type="uri" xlink:href="http://corpus-texmex.irisa.fr/" xlink:type="simple">http://corpus-texmex.irisa.fr/</ext-link>).</p>
<p><bold>Disclaimer</bold>: The authors alone are responsible for the views expressed in this article and they do not necessarily represent the views, decisions or policies of the institutions with which they are affiliated.</p>
</ack>
<glossary>
<title>Abbreviations</title>
<def-list>
<def-item><term><italic>S</italic> = (<italic>V</italic><sub>1</sub>,…,<italic>V</italic><sub><italic>n</italic></sub>)</term>
<def><p>A set of <italic>n</italic> vectors for member query</p></def>
</def-item>
<def-item><term><italic>V</italic>(<italic>v</italic><sub>1</sub>…<italic>v</italic><sub><italic>d</italic></sub>), <italic>q</italic>(<italic>q</italic><sub>1</sub>…<italic>q</italic><sub><italic>d</italic></sub>)</term>
<def><p>A vector in <italic>S</italic> and a query <italic>q</italic> with <italic>d</italic> dimensions</p></def>
</def-item>
<def-item><term><italic>P</italic>(<italic>p</italic><sub>1</sub>…<italic>p</italic><sub><italic>l</italic></sub>)</term>
<def><p>A prime number set <italic>P</italic> and a prime number <italic>p</italic><sub><italic>i</italic></sub></p></def>
</def-item>
<def-item><term>H<sup>p</sup></term>
<def><p>A Prime_HD_ BKDRHash function family with a function of <italic>h<sub>k</sub><sup>P</sup></italic> = <italic>S<sub>i</sub></italic> = ∏<italic>p</italic><sub><italic>i</italic>−1</sub>⋅<italic>S</italic><sub><italic>i</italic>−1</sub>+<italic>v<sub>i</sub></italic>(<italic>i</italic> = 1…<italic>d</italic>)</p></def>
</def-item>
<def-item><term><italic>f</italic><sub><italic>P−HDBF</italic></sub>, <italic>fnp</italic><sub><italic>P−HDBF</italic></sub></term>
<def><p>The false positive (negative) probability of P-HDBF.</p></def>
</def-item>
<def-item><term>m</term>
<def><p>The array size of P-HDBF.</p></def>
</def-item>
<def-item><term>k</term>
<def><p>The number of Prime_HD_ BKDRHash functions</p></def>
</def-item>
</def-list>
</glossary>
<ref-list>
<title>References</title>
<ref id="pone.0209159.ref001"><label>1</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Bloom</surname> <given-names>BH</given-names></name>. <article-title>Space/Time Trade-Offs in Hash Coding with Allowable Errors</article-title>. <source>Communications of the ACM</source>. <year>1970</year>; <volume>13</volume>: <fpage>422</fpage>–<lpage>426</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref002"><label>2</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Geravand</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Ahmadi</surname> <given-names>M</given-names></name>. <article-title>Bloom Filter applications in network security: A state-of-the-art survey</article-title>. <source>Computer Networks</source>. <year>2013</year>; <volume>57</volume>: <fpage>4047</fpage>–<lpage>4064</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref003"><label>3</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Mun</surname> <given-names>JH</given-names></name>, <name name-style="western"><surname>Lim</surname> <given-names>H</given-names></name>. <article-title>New approach for efficient IP address lookup using a Bloom filter in trie-based algorithms</article-title>. <source>IEEE Transactions on Computers</source>. <year>2016</year>; <volume>65</volume>: <fpage>1558</fpage>–<lpage>1565</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref004"><label>4</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Antikainen</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Aura</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Särelä</surname> <given-names>M</given-names></name>. <article-title>Denial-of-service attacks in Bloom-filter-based forwarding</article-title>. <source>IEEE/ACM Transactions on Networking (TON)</source>. <year>2014</year>; <volume>22</volume>: <fpage>1463</fpage>–<lpage>1476</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref005"><label>5</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Saravanan</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Senthilkumar</surname> <given-names>A</given-names></name>. <article-title>Security enhancement in distributed networks using link-based mapping scheme for network intrusion detection with enhanced Bloom filter</article-title>. <source>Wireless Personal Communications</source>. <year>2015</year>; <volume>84</volume>: <fpage>821</fpage>–<lpage>839</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref006"><label>6</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Tarkoma</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Rothenberg</surname> <given-names>CE</given-names></name>, <name name-style="western"><surname>Lagerspetz</surname> <given-names>E</given-names></name>. <article-title>Theory and practice of Bloom Filters for distributed systems</article-title>. <source>IEEE Communications Surveys &amp; Tutorials</source>. <year>2012</year>; <volume>14</volume>: <fpage>131</fpage>–<lpage>155</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref007"><label>7</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Jiang</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Ji</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Wang</surname> <given-names>X</given-names></name>, <name name-style="western"><surname>Zhu</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Cheng</surname> <given-names>Y</given-names></name>. <article-title>Design of a multiple Bloom filter for distributed navigation routing</article-title>. <source>IEEE Transactions On Systems, Man, And Cybernetics: Systems</source>. <year>2014</year>; <volume>44</volume>: <fpage>254</fpage>–<lpage>260</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref008"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Oigawa Y, Sato F. An Improvement in Zone Routing Protocol Using Bloom Filter. 19th International Conference on Network-Based Information Systems (NBiS); 2016 Sept 07–09; Ostrava, Czech Republic.</mixed-citation></ref>
<ref id="pone.0209159.ref009"><label>9</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Ko</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Lee</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Pack</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Kweon</surname> <given-names>K</given-names></name>. <article-title>Timer-based Bloom Filter aggregation for reducing signaling overhead in distributed mobility management</article-title>. <source>IEEE Transactions on Mobile Computing</source>. <year>2016</year>; <volume>15</volume>: <fpage>516</fpage>–<lpage>529</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref010"><label>10</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Zengin</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Schmidt</surname> <given-names>EG</given-names></name>. <article-title>A Fast and Accurate Hardware String Matching Module with Bloom Filters</article-title>. <source>IEEE Transactions on Parallel and Distributed Systems</source>. <year>2016</year>; <volume>28</volume>: <fpage>305</fpage>–<lpage>317</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref011"><label>11</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Liu</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Chen</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Wang</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>T</given-names></name>. <article-title>Page replacement algorithm based on counting Bloom filter for NAND flash memory</article-title>. <source>IEEE Transactions on Consumer Electronics</source>. <year>2014</year>; <volume>60</volume>: <fpage>636</fpage>–<lpage>643</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref012"><label>12</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Fan</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Cao</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Almeida</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Broder</surname> <given-names>AZ</given-names></name>. <article-title>Summary cache: a scalable wide-area web cache sharing protocol. IEEE/ACM Trans</article-title>. <source>Networking</source>. <year>2000</year>; <volume>8</volume>: <fpage>281</fpage>–<lpage>293</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref013"><label>13</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Pontarelli</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Reviriego</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Maestro</surname> <given-names>JA</given-names></name>. <article-title>Improving counting Bloom filter performance with fingerprints</article-title>. <source>Information Processing Letters</source>. <year>2016</year>; <volume>116</volume>: <fpage>304</fpage>–<lpage>309</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref014"><label>14</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Lim</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Lee</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Byun</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Yim</surname> <given-names>C</given-names></name>. <article-title>Ternary Bloom Filter Replacing Counting Bloom Filter</article-title>. <source>IEEE Communications Letters</source>. <year>2017</year>; <volume>21</volume>: <fpage>278</fpage>–<lpage>281</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref015"><label>15</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Mitzenmacher</surname> <given-names>M.</given-names></name> <article-title>Compressed Bloom Filters</article-title>. <source>IEEE/ACM Transactions on Networking</source>. <year>2002</year>; <volume>10</volume>: <fpage>604</fpage>–<lpage>612</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref016"><label>16</label><mixed-citation publication-type="other" xlink:type="simple">Cohen S, Matias Y. Spectral Bloom Filters. Proceedings of the 2003 ACM SIGMOD international conference on Management of data; 2003 June 09–12; San Diego, California, US.</mixed-citation></ref>
<ref id="pone.0209159.ref017"><label>17</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Guo</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Chen</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Yuan</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Luo</surname> <given-names>X</given-names></name>. <article-title>The dynamic Bloom Filters</article-title>. <source>IEEE Transactions on Knowledge and Data Engineering</source>. <year>2010</year>; <volume>22</volume>: <fpage>120</fpage>–<lpage>133</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref018"><label>18</label><mixed-citation publication-type="other" xlink:type="simple">Fan B, Andersen DG, Kaminsky M, Mitzenmacher MD. Cuckoo filter: Practically better than bloom. Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies; 2014 December 02–05; Sydney, Australia.</mixed-citation></ref>
<ref id="pone.0209159.ref019"><label>19</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Xiao</surname> <given-names>MZ</given-names></name>, <name name-style="western"><surname>Dai</surname> <given-names>YF</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>XM</given-names></name>. <article-title>Split Bloom Filters</article-title>. <source>Acta Electronica Sinica</source>. <year>2004</year>; <volume>32</volume>: <fpage>241</fpage>–<lpage>245</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref020"><label>20</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Xiao</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Hua</surname> <given-names>Y</given-names></name>. <article-title>Using parallel Bloom Filters for multiattribute representation on network services</article-title>. <source>IEEE Transactions on parallel and distributed systems</source>. <year>2010</year>; <volume>21</volume>: <fpage>20</fpage>–<lpage>32</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref021"><label>21</label><mixed-citation publication-type="other" xlink:type="simple">Partow A. General Purpose Hash Function Algorithms. 2013. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.partow.ne-t/programming/hashfunctions/DEKHashFunction" xlink:type="simple">http://www.partow.ne-t/programming/hashfunctions/DEKHashFunction</ext-link></mixed-citation></ref>
<ref id="pone.0209159.ref022"><label>22</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Kirsch</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Mitzenmacher</surname> <given-names>M</given-names></name>. <article-title>Distance-Sensitive Bloom Filters. In: The Eighth Workshop on Algorithm Engineering and Experiments (ALENEX06)</article-title>. <source>Society for Industrial and Applied Mathematics</source>; <year>2006</year>. pp. <fpage>41</fpage>–<lpage>51</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref023"><label>23</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Hua</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Xiao</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Veeravalli</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Feng</surname> <given-names>D</given-names></name>. <article-title>Locality-sensitive Bloom Filter for Approximate Membership Query</article-title>. <source>IEEE Transactions on Computers</source>. <year>2012</year>; <volume>61</volume>: <fpage>817</fpage>–<lpage>830</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref024"><label>24</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Qian</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Zhu</surname> <given-names>Q</given-names></name>, <name name-style="western"><surname>Chen</surname> <given-names>H</given-names></name>. <article-title>Multi-Granularity Locality-Sensitive Bloom Filter</article-title>. <source>IEEE Transactions on Computers</source>. <year>2015</year>; <volume>64</volume>: <fpage>3500</fpage>–<lpage>3514</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref025"><label>25</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Qian</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Zhu</surname> <given-names>Q</given-names></name>, <name name-style="western"><surname>Chen</surname> <given-names>H</given-names></name>. <article-title>Integer-Granularity Locality-Sensitive Bloom Filter</article-title>. <source>IEEE Communications Letters</source>. <year>2016</year>; <volume>20</volume>: <fpage>2125</fpage>–<lpage>2128</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref026"><label>26</label><mixed-citation publication-type="book" xlink:type="simple"><name name-style="western"><surname>Datar</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Immorlica</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Indyk</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Mirrokni</surname> <given-names>VS</given-names></name>. <chapter-title>Locality-Sensitive Hashing Scheme Based on P-Stable Distributions</chapter-title>. In: <source>Proceedings of the twentieth annual symposium on Computational geometry</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM</publisher-name>; <year>2004</year>. pp. <fpage>253</fpage>–<lpage>262</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref027"><label>27</label><mixed-citation publication-type="book" xlink:type="simple"><name name-style="western"><surname>Kernighan</surname> <given-names>BW</given-names></name>, <name name-style="western"><surname>Ritchie</surname> <given-names>D</given-names></name>. <chapter-title>C Programming Language</chapter-title>. <edition>2nd ed.</edition> <publisher-loc>London</publisher-loc>: <publisher-name>Prentice-Hall</publisher-name>; <year>1988</year>.</mixed-citation></ref>
<ref id="pone.0209159.ref028"><label>28</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Rottenstreich</surname> <given-names>O</given-names></name>, <name name-style="western"><surname>Keslassy</surname> <given-names>I</given-names></name>. <article-title>The Bloom paradox: When not to use a Bloom Filter</article-title>. <source>IEEE/ACM Transactions on Networking (TON)</source>. <year>2015</year>; <volume>23</volume>: <fpage>703</fpage>–<lpage>716</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref029"><label>29</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Bose</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Guo</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Kranakis</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Maheshwari</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Morin</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Morrison</surname> <given-names>J</given-names></name>, <etal>et al</etal>. <article-title>On the false-positive rate of Bloom filters</article-title>. <source>Information Processing Letters</source>. <year>2008</year>; <volume>108</volume>: <fpage>210</fpage>–<lpage>213</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref030"><label>30</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Christensen</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Roginsky</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Jimeno</surname> <given-names>M</given-names></name>. <article-title>A new analysis of the false positive rate of a Bloom filter</article-title>. <source>Information Processing Letters</source> <year>2010</year>; <volume>110</volume>: <fpage>944</fpage>–<lpage>949</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref031"><label>31</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Rottenstreich</surname> <given-names>O</given-names></name>, <name name-style="western"><surname>Kanizo</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Keslassy</surname> <given-names>I</given-names></name>. <article-title>The variable-increment counting Bloom filter</article-title>. <source>IEEE/ACM Transactions on Networking (TON)</source>. <year>2014</year>; <volume>22</volume>: <fpage>1092</fpage>–<lpage>1105</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref032"><label>32</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Qiao</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Chen</surname> <given-names>S</given-names></name>. <article-title>Fast Bloom Filters and their generalization</article-title>. <source>IEEE Transactions on Parallel and Distributed Systems</source>. <year>2014</year>; <volume>25</volume>: <fpage>93</fpage>–<lpage>103</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref033"><label>33</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Reviriego</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Christensen</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Maestro</surname> <given-names>JA</given-names></name>. <article-title>A Comment on “Fast Bloom Filters and Their Generalization”</article-title>. <source>IEEE Transactions on Parallel and Distributed Systems</source>. <year>2016</year>; <volume>27</volume>: <fpage>303</fpage>–<lpage>304</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref034"><label>34</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Crainiceanu</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Lemire</surname> <given-names>D</given-names></name>. <article-title>Bloofi: Multidimensional Bloom Filters</article-title>. <source>Information Systems</source>. <year>2015</year>; <volume>54</volume>: <fpage>311</fpage>–<lpage>324</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref035"><label>35</label><mixed-citation publication-type="book" xlink:type="simple"><name name-style="western"><surname>Fu</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Biersack</surname> <given-names>E</given-names></name>. <chapter-title>False-Positive Probability and Compression Optimization for Tree-Structured Bloom Filters</chapter-title>. <publisher-name>ACM Transactions on Modeling and Performance Evaluation of Computing Systems (TOMPECS)</publisher-name>. <year>2016</year>; <volume>1</volume>: <fpage>19</fpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref036"><label>36</label><mixed-citation publication-type="book" xlink:type="simple"><name name-style="western"><surname>Heyde</surname> <given-names>CC</given-names></name>. <chapter-title>Central Limit Theorem</chapter-title>. In: <source>Convergence of Stochastic Processes</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer</publisher-name>; <year>1984</year>. pp. <fpage>3244</fpage>–<lpage>3248</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref037"><label>37</label><mixed-citation publication-type="book" xlink:type="simple"><name name-style="western"><surname>Katz</surname> <given-names>VJ</given-names></name>. <chapter-title>Chapter 3: Chinese Mathematics</chapter-title>. In: <source>The Mathematics of Egypt, Mesopotamia, China, India and Islam: A Sourcebook</source>. <publisher-name>Princeton University Pres</publisher-name>; <year>2007</year>. pp. <fpage>187</fpage>–<lpage>384</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref038"><label>38</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Feistel</surname> <given-names>H</given-names></name>. <article-title>Cryptography and Computer Privacy</article-title>. <source>Scientific American</source>. <year>1973</year>; <volume>228</volume>:<fpage>15</fpage>–<lpage>23</lpage>.</mixed-citation></ref>
<ref id="pone.0209159.ref039"><label>39</label><mixed-citation publication-type="other" xlink:type="simple">Fagin R, Kumar R, Sivakumar D. Efficient similarity search and classification via rank aggregation. Proceedings of the 2003 ACM SIGMOD international conference on Management of data; 2003 June 09–12; San Diego, California, US.</mixed-citation></ref>
<ref id="pone.0209159.ref040"><label>40</label><mixed-citation publication-type="other" xlink:type="simple">Amsaleg L. Datasets for approximate nearest neighbor search. 2017. Available from: <ext-link ext-link-type="uri" xlink:href="http://corpus-texmex.irisa.fr/" xlink:type="simple">http://corpus-texmex.irisa.fr/</ext-link></mixed-citation></ref>
</ref-list>
</back>
</article>